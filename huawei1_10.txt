/*
题目描述
定差值的组合.cpp
给定一个数组，每个元素的值是唯一的，找出其中两个元素相减等于给定差值 diff 的所有不同组合的个数。

组合是无序的：如：（1, 4)和(4, 1)表示的是同一个组合。
解答要求
时间限制：1000ms, 内存限制：256MB
输入
输入三行:
第一行为一个整数，表示给定差值diff；范围[-50000, 50000]
第二行也为一个数字，表示数组的长度；范围[2, 102400]
第三行为该数组，由单个空格分割的一组数字组成；其中元素的值范围[-20, 102400]

用例保证第三行数字和空格组成的字符串长度不超过 649999

输出
1个整数，表示满足要求的不同组合的个数

样例
输入样例 1 复制

3
5
1 3 2 5 4
输出样例 1

2
提示
数组为[1 3 2 5 4]， 差值 diff 为 3，其中 4 - 1 = 3，5 - 2 = 3，共 2 个组合满足条件，因此输出 2



输入样例 2 复制

-1
3
1 2 3
输出样例 2

2
提示
其中 1 - 2 = -1，2 - 3 = -1，共 2 个组合满足条件，因此输出 2。
*/
/*
int Proc(const vector<int> &arr, int diff)
{
    // 在此添加你的代码
    if (diff == 0) {
        return 0;
    }
    auto tmp = arr;
    sort(tmp.begin(), tmp.end(), less<int>());
    int cnt = 0;
    for (int i = 0; i < tmp.size(); ++i) {
        if (binary_search(tmp.begin(), tmp.end(), tmp[i] + diff)) {
            cnt++;
        }
    }
    return cnt;
}

// 以下为考题输入输出框架，此部分代码不建议改动
int main()
{
    string line;
    getline(cin, line);
    int diff = stoi(line);

    getline(cin, line);
    int n = stoi(line);
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    cout << Proc(arr, diff) << endl;
    return 0;
}
*/
/*
服务器集群网络延迟.cpp
输入
第一行整数 n，代表数组元素的个数，取值范围：[1, 500]。
第二行是n个数值，表示上述数组的元素（单个空格间隔），取值范围: [1, 10000]。

输出
一个整数，表示集群网络延迟的最小值。

样例
输入样例 1 复制

3
2 6 4
输出样例 1

4
提示
选择机位编号为4的服务器作为主服务器，集群网络延迟最小：|2-4| + |4-6| = 4。



输入样例 2 复制

4
2 4 3 1
输出样例 2

4
*/
/*
#include <bits/stdc++.h>
using namespace std;

int ClusterLatency(const vector<int> &arr)
{
    // 在此添加你的代码
    auto tmp = arr;
    sort(tmp.begin(), tmp.end());
    // 找到中位数
    int len = tmp.size();
    int key = len % 2 ? tmp[(len - 1) / 2] : tmp[len / 2];
    // 计算延迟
    int cnt = 0;
    for (auto i : arr) {
        cnt += abs(key - i);
    }
    return cnt;
}

// 以下为考题输入输出框架，此部分代码不建议改动
int main()
{
    string line;
    getline(cin, line);
    int n = stoi(line);
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    cout << ClusterLatency(arr) << endl;
    return 0;
}
*/

/*
合法mac地址.cpp
题目描述
给定一个字符串，从中按如下规则找出所有的合法mac地址的数量：

合法 mac 地址以字符串表示时，由 12 位十六进制字符组成，每两个字符之间被 - 或 :分割
十六进制字符包括 0-9, a-f, A-F；同一个 mac 中出现的字母可以大小写混用
同一个 mac 地址，- 与 : 不能混用
相同 mac 地址需去重统计；注意，仅大小写、分割符不同的两个mac地址字符串视为相同，如 aa-bb-12-cc-dd-ee 与 Aa:bB:12:CC:dd:ee 视为相同。
解答要求
时间限制：1000ms, 内存限制：64MB
输入
字符串，长度取值范围：[1,1000]

输出
整数，表示去重后的合法mac地址的个数

样例
输入样例 1 复制

01-02-03-04-05-06-07
输出样例 1

2
提示
包含2个合法的 mac 地址01-02-03-04-05-06和02-03-04-05-06-07



输入样例 2 复制

01:02:03:002-03-04-05-06-07
输出样例 2

1
提示
包含1个合法的 mac 地址02-03-04-05-06-07



输入样例 3 复制

0a-0a-0a-0a-0a-0a-0A
输出样例 3

1
提示
包含 mac 地址0a-0a-0a-0a-0a-0a和0a-0a-0a-0a-0a-0A, 去重后返回为1


*/

/*
#include <bits/stdc++.h>
using namespace std;
// 待实现函数，在此函数中填入答题代码
class Solution {
public:
    int GetMacNum(string ins)
    {
        set<string> s;
        for (int i = 0; i + 17 <= ins.size(); i++) {
            string tmp = ins.substr(i, 17);
            if (IsValid(tmp)) {
                Reshape(tmp);
                s.insert(tmp);
            }
        }
        return s.size();
    }
    void Reshape(string &s)
    {
        for (auto &ch : s) {
            if (ch == ':') {
                ch = '-';
            }
            ch = toupper(ch);
        }
    }
    bool IsHex(char ch)
    {
        if (ch >= '0' && ch <= '9') {
            return true;
        }
        if (ch >= 'a' && ch <= 'f' ) {
            return true;
        }
        if (ch >= 'A' && ch <= 'F') {
            return true;
        }
        return false;
    }
    bool IsValid(string s)
    {
        int tmp = max(count(s.begin(), s.end(), '-'), count(s.begin(), s.end(), ':'));
        if (tmp != 5) {
            return false;
        }
        for (int i = 0; i < s.size(); i++) {
            if ((i+1) % 3 != 0 && !IsHex(s[i])) {
                return false;
            }
        }
        return true;
    }
};
// 以下为考题输入输出框架，此部分代码不建议改动
inline std::string ReadLine()
{
    std::string line;
    std::getline(std::cin, line);
    return line;
}
int main()
{
    string instr = ReadLine();
    Solution solu;
    int res = solu.GetMacNum(instr);
    cout << res;
    return 0;
}
*/

/*
计算面积.cpp
题目描述
绘图机器的绘图笔初始位置在原点（0, 0），机器启动后其绘图笔按下面规则绘制直线：
1）尝试沿着横向坐标轴正向绘制直线，直到给定的终点值E。
2）期间可通过指令在纵坐标轴方向进行偏移，并同时绘制直线，偏移后按规则1 绘制直线；指令的格式为X offsetY，表示在横坐标X 沿纵坐标方向偏移，offsetY为正数表示正向偏移，为负数表示负向偏移。

给定了横坐标终点值E、以及若干条绘制指令，请计算绘制的直线和横坐标轴、以及 X=E 的直线组成图形的面积。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
首行为两个整数 N E，表示有N条指令，机器运行的横坐标终点值E。
接下来N行，每行两个整数表示一条绘制指令X offsetY，用例保证横坐标 X 以递增排序方式出现，且不会出现相同横坐标 X 。
取值范围：0 < N <= 10000, 0 <= X <= E <= 20000, -10000 <= offsetY <= 10000。

输出
一个整数，表示计算得到的面积，用例保证，结果范围在 0~4294967295 内

样例
输入样例 1 复制

4 10
1 1
2 1
3 1
4 -2
输出样例 1

12
提示


输入样例 2 复制

2 4
0 1
2 -2

输出样例 2

4
*/
/*
#include <bits/stdc++.h>

using namespace std;
unsigned int GetMinArea(int stopPoint, const vector<pair<int, int>> &operations)
{
    int curx=0;
    int cury=0;
    int res=0;
    for(auto p:operations)
    {
        res+=(p.first-curx)*abs(cury);
        curx=p.first;
        cury+=p.second;
    }

    res+=(stopPoint-curx)*abs(cury);
    return res;
}

int main()
{
    int num, stopPoint;
    cin >> num >> stopPoint;
    
    vector<pair<int, int> > operations;
    for (int loop = 0; loop < num; loop++) {
        int x, value;
        cin >> x >> value;
        operations.push_back(make_pair(x, value));
    }
  
    cout << GetMinArea(stopPoint, operations) << endl;
    
    return 0;
}
*/

/*
简易内存池.cpp
题目描述
请实现一个简易内存池,根据请求命令完成内存分配和释放。
内存池支持两种操作命令，REQUEST和RELEASE，其格式为：
REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error。
RELEASE=释放的内存首地址 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。
注意：
1.内存池总大小为100字节。
2.内存池地址分配必须是连续内存，并优先从低地址分配。
3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。
4.不会释放已申请的内存块的中间地址。
5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
首行为整数 N , 表示操作命令的个数，取值范围：0 < N <= 100。
接下来的N行, 每行将给出一个操作命令，操作命令和参数之间用 “=”分割。
输出
见题面输出要求

样例
输入样例 1 复制

2
REQUEST=10
REQUEST=20

输出样例 1

0
10
提示


输入样例 2 复制

5
REQUEST=10
REQUEST=20
RELEASE=0
REQUEST=20
REQUEST=10
输出样例 2

0
10
30
0
提示
第一条指令，申请地址0~9的10个字节内存，返回首地址0
第二条指令，申请地址10~29的20字节内存，返回首地址10
第三条指令，释放首地址为0的内存申请，0~9地址内存被释放，变为空闲，释放成功，无需输出
第四条指令，申请20字节内存，0~9地址内存连续空间不足20字节，往后查找到30~49地址，返回首地址30
第五条指令，申请10字节，0~9地址内存空间足够，返回首地址0
*/

/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.
 * Description: 考生实现代码
 * Note: 缺省代码仅供参考，可自行决定使用、修改或删除
 */
 /*
#include <bits/stdc++.h>
using namespace std;
#define MAX_SIZE 100
class MiniMemoryPool {
public:
    vector<int> memPool;
    MiniMemoryPool() 
    {
        memPool.resize(100,-1);//初始化size为100的内存池
    }
    // 返回分配的内存首地址,失败返回 -1
    int Request(int size)
    {
        if (size > 100 || size <= 0) {
            return -1;    
        }
        int start = 0; // 申请内存块的头尾,范围是[start,end)
        int end = 0;
        while (end < memPool.size() && (end - start) < size) {
            if (memPool[end] != -1) { //end对应的地址已经被申请,更新申请的起点start
                start = end + 1;
            }
            end++;
        }
        if ((end - start) == size) { //申请到了[start,end)的地址段,更新每个单位的值为首地址
            for (int i = start; i < end; i++) {
                memPool[i] = start;
            }
            return start;
        }
        return -1;
    }
    // 释放内存地址, 成功返回 true, 失败返回 false
    bool Release(int startAddr)
    {
        if (memPool[startAddr] != startAddr) { //释放的首地址的值不是它自身,说明此地址未使用或者是中间地址
            return false;
        }
        for (int i = startAddr; i < memPool.size() && memPool[i] == startAddr; i++) {
            memPool[i] = -1;//从释放的首地址开始，将释放的所有地址设为未使用(-1)
        }
        return true;
    }
};

int main()
{
    int num;
    cin >> num;

    MiniMemoryPool pool;
    for (int loop = 0; loop < num; loop++) {
        string line;
        cin >> line;

        string commond = line.substr(0, line.find_first_of('='));
        if (commond == "REQUEST") {
            int size = stoi(line.substr(line.find_first_of('=')+1));
            int result = pool.Request(size);
            if (result != -1) {
                cout << result << endl;
            } else {
                cout << "error" << endl;
            }
        } else if (commond == "RELEASE") {
            int addr = stoi(line.substr(line.find_first_of('=')+1));
            if (!pool.Release(addr)) {
                cout << "error" << endl;
            }
        }
    }

    return 0;
}

*/

/*
矩阵转置
题目描述
一个正方矩阵是长宽等长，由单个十进制数字字符构成的矩阵。 比如，这是一个 3 x 3 的正方矩阵：

2	3	5
7	4	3
8	1	9
该正方矩阵有两种表达：

行优先表达：即先从左到右，再从上到下罗列所有元素；上述正方矩阵描述为235743819
列优先表达：即先从上到下，再从左到右罗列所有元素；上述正方矩阵描述为278341539
给定正方矩阵的行优先表达，请输出对应的列优先表达；如果输入不能表达为一个正方矩阵，即长度不满足整数平方数时，对应输出字符串 ERROR。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
一个字符串，表示矩阵的行优先表达，仅由数字字符 0-9 组成，长度范围 [1, 10000]。

输出
一个字符串，表示矩阵的列优先表达 ，或字符串ERROR。

样例
输入样例 1 复制

435245019
输出样例 1

420341559
提示
无



输入样例 2 复制

0123456789
输出样例 2

ERROR
提示
10个数字字符，不能表达为一个正方矩阵，输出为 ERROR 。
*/
/*
#include <iostream>
#include <sstream>
#include <string>
#include <cmath>
#include <utility>
#include <algorithm>
using namespace std;

class Solution {
public:
    // 待实现函数，在此函数中填入答题代码
    string Transpose(const string& str)
    {
    int len = str.size();
    int n, i;

    string tmp=str;
    // 判断长度是否为某个数的平方 
    for (n = 1; n <= 100; n++) {
        if (n * n == len) {
            break;
        }
    }
    if (n == 101) {
        tmp="ERROR";
        return tmp;
    }
    // 将行转为列 
    
    for (i = 0; i < len; i++) {
        tmp[i / n + i % n * n] = str[i];
    }
   
    return tmp;
    }
};

int main()
{
    string str;
    cin >> str;
    
    Solution solu;
    string output = solu.Transpose(str);
    cout << output << endl;

    return 0;
}

*/

/*题目描述
设备编号.cpp
给定一个设备编号区间[start, end]，包含4或18的编号都不能使用，如：418、148、718不能使用，108可用。

请问有多少可用设备编号。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
两个整数start end(单空格间隔)，用于标识设备编号区间，0 < start < end <= 100000

输出
一个整数，代表可用设备编号的数量

样例
输入样例 1 复制

3 20
输出样例 1

15
提示
不能使用的设备编号为4、14、18



输入样例 2 复制

1 1000
输出样例 2

711
*/
/*
#include <iostream>
using namespace std;

class Solution {
public:
    // 待实现函数，在此函数中填入答题代码;
    int GetNormalDeviceNum(int start, int end) const
    {
        int result = 0;
        for (int i = start; i <= end; i++) {
            string s = to_string(i);
            if (s.find("4") != string::npos || s.find("18") != string::npos) {
                continue;
            }
            result++;
        }
        return result;
    }
};

// 以下为考题输入输出框架，此部分代码不建议改动
inline int ReadInt()
{
    int number;
    std::cin >> number;
    return number;
}

int main()
{
    int start = ReadInt();
    int end = ReadInt();

    Solution solu;
    int result = solu.GetNormalDeviceNum(start, end);
    cout << result;

    return 0;
}
*/

/*
最佳路径.cpp
首行为两个正整数n m

n 是单板间连接关系的数量，取值范围：[1, 500]
m 是查询命令的个数，取值范围：[1, 500]
接下来n行，每行是连接关系，单板编号取值范围：[1, 999]，权值取值范围：[1,100]；都为正整数

接下来m行，每行是需要查询最佳路径权值的起始单板、目的单板的编号。

输出
m行，每行一个整数，表示对应起始单板、目的单板的最佳路径权值的查询结果

样例
输入样例 1 复制

2 2
100 101 10
102 101 5
100 101
102 100
输出样例 1

10
-1
提示
输出第一行：单板100到单板101，最少经过1次跳转就可达，其权值为10，输出10
输出第二行：单板102到单板100，没有路径可达，因此输出-1
*/
/*
#include <iostream>
#include <map>
#include <queue>
using namespace std;

const int MAX_SIZE = 1000;
const int MAX_WEIGHT = 100;
const int MAX_CONNECTION = 500;
const int PENALTY = MAX_WEIGHT * MAX_CONNECTION;
int g_connection[MAX_SIZE][MAX_SIZE] = {-1};

class Solution {
public:
    // 待实现函数，在此函数中填入答题代码;
    vector<int> GetBestRoute(const vector<vector<int>> &connection, const vector<vector<int>> &routes)
    {
        fill(g_connection[0], g_connection[0] + MAX_SIZE * MAX_SIZE, -1);
        int tmpMax = 0;
        for (auto v : connection) {
            g_connection[v[0]][v[1]] = v[2];
            tmpMax = max(tmpMax, max(v[0], v[1])) + 1;  // avoid time execeed
        }
        for (int k = 0; k < tmpMax; k++) {
            for (int i = 0; i < tmpMax; i++) {
                for (int j = 0; j < tmpMax; j++) {
                    if (g_connection[i][k] > 0 && g_connection[k][j] > 0) {
                        int tmp = g_connection[i][k] + g_connection[k][j] + PENALTY;  // weight with penalty
                        g_connection[i][j] = (g_connection[i][j] == -1) ? tmp : min(tmp, g_connection[i][j]);
                    }
                }
            }
        }
        vector<int> res;
        for (auto v : routes) {
            res.push_back(g_connection[v[0]][v[1]] % PENALTY);
        }
        return res;
    }
};

// 以下为考题输入输出框架，此部分代码不建议改动
int main()
{
    int n, m;
    cin >> n >> m;
    int board1, board2, weight;
    vector<vector<int>> connections(n, vector<int>(3, 0));
    for (int loop = 0; loop < n; loop++) {
        cin >> board1 >> board2 >> weight;
        connections[loop][0] = board1;
        connections[loop][1] = board2;
        connections[loop][2] = weight;
    }

    vector<vector<int>> routes(m, vector<int>(2, 0));
    for (int loop = 0; loop < m; loop++) {
        cin >> board1 >> board2;
        routes[loop][0] = board1;
        routes[loop][1] = board2;
    }

    Solution solu;
    vector<int> res = solu.GetBestRoute(connections, routes);
    for (auto r : res) {
        cout << r << endl;
    }

    return 0;
}

*/

/*
题目描述
最长的指定瑕疵度的元音子串.cpp
定义：开头和结尾都是元音字母（aeiouAEIOU）的字符串为 元音字符串 ，其中混杂的非元音字母数量为其 瑕疵度 。比如:

“a” 、 “aa”是元音字符串，其瑕疵度都为0
“aiur”不是元音字符串（结尾不是元音字符）
“abira”是元音字符串，其瑕疵度为2
给定一个字符串，请找出指定瑕疵度的最长元音字符子串，并输出其长度，如果找不到满足条件的元音字符子串，输出0。

子串：字符串中任意个连续的字符组成的子序列称为该字符串的子串。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
首行输入是一个整数，表示预期的瑕疵度flaw，取值范围 [0, 65535]。
接下来一行是一个仅由字符a-z和A-Z组成的字符串，字符串长度 (0, 65535]。

输出
输出为一个整数，代表满足条件的元音字符子串的长度。

样例
输入样例 1 复制

0
asdbuiodevauufgh
输出样例 1

3
提示
满足条件的最长元音字符子串有两个，分别为uio和auu，长度为3。



输入样例 2 复制

2
aeueo
输出样例 2

0
提示
没有满足条件的元音字符子串，输出0



输入样例 3 复制

1
aabeebuu
输出样例 3

5
提示
满足条件的最长元音字符子串有两个，分别为aabee和eebuu，长度为5
*/
/*
#include <iostream>
#include <string>

using namespace std;
int GetLongestFlawedVowelSubstrLen(const size_t flaw, const string &input)
{
    int curFlaw = 0;
    int curMaxLen = 0;
    int left = 0;
    int right = 0;
    string vowel = "aeiouAEIOU";
    while (left < input.size() && right < input.size()) {
        if (vowel.find(input[right]) == string::npos) {
            curFlaw++;
        }
        if (curFlaw > flaw) {
            while (left < right) {
                if (vowel.find(input[left]) == string::npos) {
                    curFlaw--;
                }
                left++;
                if (curFlaw <= flaw) {
                    break;
                }
            }
        }
        if (curFlaw == flaw && vowel.find(input[left]) != string::npos && vowel.find(input[right]) != string::npos) {
            curMaxLen = max(curMaxLen, right - left + 1);
        }
        right++;
    }
    return curMaxLen;
}

int main()
{
    size_t flaw;
    cin >> flaw;

    string input;
    cin >> input;

    cout << GetLongestFlawedVowelSubstrLen(flaw, input) << endl;
    return 0;
}

*/

/*
最长元音子串的长度.cpp
题目描述
定义：当一个字符串只有元音字母（aeiouAEIOU）组成，称为元音字符串。
现给定一个字符串，请找出其中最长的元音字符子串，并返回其长度；如果找不到，则返回0。

子串：字符串中任意个连续的字符组成的子序列称为该字符串的子串。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
一个字符串，其长度范围： 0 < length <= 65535。

字符串仅由字符a-z和A-Z组成。

输出
一个整数，表示最长的元音字符子串的长度。

样例
输入样例 1 复制

asdbuiodevauufgh
输出样例 1

3
提示
最长元音子串为 “uio” 或 “auu”，其长度都为3，因此输出3
*/
/*
#include <iostream>
#include <string>

using namespace std;
int GetLongestVowelStringLength(const string& input)
{
    const string ALL_VOWEL="aeiouAEIOU";
    int res=0;
    int tmp=0;
    for(auto ch:input)
    {
        if(ALL_VOWEL.find(ch)!=string::npos)
        {
            tmp++;
        }else
        {
            res=max(res,tmp);
            tmp=0;
        }
        
    }
    res=max(res,tmp);
    return res;
}

int main()
{
    string input;
    cin >> input;

    cout << GetLongestVowelStringLength(input) << endl;
    return 0;
}
*/
